java 常见面试题

1并发和并行有啥区别？
并发是多个事件在同一时间段执行，而并行是多个事件在同一时间点执行。

2.线程和进程的区别：
（1）进程拥有独立的堆栈空间和数据段，所以每当启动一个新的进程必须分派给他独立的地址及其空间，
建立众多的数据表来维护他的代码段。堆栈段，数据段，系统开销大，而线程不一样。线程拥有独立的堆栈空间。
但是共享数据段。他们彼此使用相同的数据空间地址。比进程更加节约。开销比较小。切换速度比进程更加快速，
效率高，但是正犹豫进程之间独立的特点。使用进程安全性更加高，而线程只是在进程中的不同执行路径中。一个线程
死掉就等于一个进程死掉。
（2）体现在通讯机制中，进程之间互不干扰，进程之间相互独立，进程之间的通信相对来说比较复杂。比如管道。信号，消息队列。共享内存，
套接字等通信机制，而线程共享数据段进行通信，更加方便。
（3）属于同一个进程的所有线程共享该进程的所有资源，包括文件描述符，而不同的进程之间相互独立。
（4）线程又称之为轻量级的进程，进程有进程控制块，线程又线程控制块，
（5）线程必定属于一个进程，而进程可以拥有多个线程而且至少拥有一个线程。
3.守护进程是什么？

守护进程是指在程序运行的时候后台提供一种通信服务线程。比如垃圾回收线程就称之为守护者。并且这种线程不属于程序中不可缺少的
部分。因此，当所有的非守护进程结束时，程序也就终止了。同时会杀死进程中的所有守护线程。只要有任何非守护进程在运行，程序就不会，
终止。

守护线程和用户线程本质上没有啥区别。唯一的不同在于虚拟机的离开。如果用户线程已经全部退出运行了。之
身下守护线程，虚拟机就会退出了。 因为没有被守护者，守护线程就没有事情可以做了，也没有运行的必要了。
将线程设置为守护线程可以通过Thread 对象中中的  setDeamon(true) 方式实现。
设置为守护线程必须注意在start() 之前设置。否则会出现  异常。在deamon线程中创建的线程也是守护线程。

守护线程应该永远不去访问固有资源。数据库，文件。应为他会在任何时候甚至在操作中发生中断。

4.Runnable 和 Callable有啥区别？ 
 Runnable 中执行的是Run 方法，callable中调用的是call（）；
 run () 中不会反会结果。因为返回值为void 。而callable()是个支持泛型的接口，当要实现implement 一个Callable
 接口的时候，必须提供一个返回值类型
run () 接口中不会抛出异常。而call() 中可以抛出异常。


5 线程有哪些状态？ 
（New） 新建
当使用new 操作时创建一个线程时，该线程还没有运行，者以外他的状态都是new 状态，
（Runnable） 可运行/就绪状态 。
一旦新状态线程调用start() 方法，线程就处在Runnable  状态。
（Running） 运行中
当线程获得CPU 时间片，线程进入Running 态，而run 方法没有运行完，线程就处在Runnable 状态。
通常情况下   运行中的线程一直处在Running 和Runnable 交替转换状态。
Blocked(等待/阻塞/睡眠)
 当线程在Running 状态中，遇到阻塞状态等待锁  等待用户输入调用sleep() 方法，调用join() 
 等待其他线程情况，会导致线程进入阻塞状态，
 处于阻塞状态的线程，在阻塞等待结束了之后会进入Runnable状态。等待CPU时间段继续运行程序。
 
Dead (死亡状态)
当线程运行完成run() 方法。直接进入死亡状态dead.

sleep（）和wait() 有啥区别？
（使用限制)使用sleep()方法可以让当前线程休眠。时间等道当前线程继续往下执行。在任何地方都能使用。
但是需要捕获打断异常。而wait() 还需要notify() notifyAll()进行唤醒。他们需要放在synchronized 代码块中。
切获取对象的锁。
使用场景:sleep()一般用在当前线程休眠。或者循环中暂停操作。wait() 用在多线程之间的通信。
所属类：sleep 为  Thread 类中的静态方法。wait() 则是Object类中的本地方法。
释放锁:wait ()可以释放当前线程中锁。而sleep() 方法不会释放线程中的锁。


