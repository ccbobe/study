## java 常见面试题

### 1并发和并行有啥区别？

并发是多个事件在同一时间段执行，而并行是多个事件在同一时间点执行。

### 2.线程和进程的区别：

（1）进程拥有独立的堆栈空间和数据段，所以每当启动一个新的进程必须分派给他独立的地址及其空间，
建立众多的数据表来维护他的代码段。堆栈段，数据段，系统开销大，而线程不一样。线程拥有独立的堆栈空间。
但是共享数据段。他们彼此使用相同的数据空间地址。比进程更加节约。开销比较小。切换速度比进程更加快速，
效率高，但是正犹豫进程之间独立的特点。使用进程安全性更加高，而线程只是在进程中的不同执行路径中。一个线程
死掉就等于一个进程死掉。
（2）体现在通讯机制中，进程之间互不干扰，进程之间相互独立，进程之间的通信相对来说比较复杂。比如管道。信号，消息队列。共享内存，
套接字等通信机制，而线程共享数据段进行通信，更加方便。
（3）属于同一个进程的所有线程共享该进程的所有资源，包括文件描述符，而不同的进程之间相互独立。
（4）线程又称之为轻量级的进程，进程有进程控制块，线程又线程控制块，
（5）线程必定属于一个进程，而进程可以拥有多个线程而且至少拥有一个线程。
3.守护进程是什么？

守护进程是指在程序运行的时候后台提供一种通信服务线程。比如垃圾回收线程就称之为守护者。并且这种线程不属于程序中不可缺少的
部分。因此，当所有的非守护进程结束时，程序也就终止了。同时会杀死进程中的所有守护线程。只要有任何非守护进程在运行，程序就不会，
终止。

守护线程和用户线程本质上没有啥区别。唯一的不同在于虚拟机的离开。如果用户线程已经全部退出运行了。之
身下守护线程，虚拟机就会退出了。 因为没有被守护者，守护线程就没有事情可以做了，也没有运行的必要了。
将线程设置为守护线程可以通过Thread 对象中中的  setDeamon(true) 方式实现。
设置为守护线程必须注意在start() 之前设置。否则会出现  异常。在deamon线程中创建的线程也是守护线程。

守护线程应该永远不去访问固有资源。数据库，文件。应为他会在任何时候甚至在操作中发生中断。

4.Runnable 和 Callable有啥区别？ 
 Runnable 中执行的是Run 方法，callable中调用的是call（）；
 run () 中不会反会结果。因为返回值为void 。而callable()是个支持泛型的接口，当要实现implement 一个Callable
 接口的时候，必须提供一个返回值类型
run () 接口中不会抛出异常。而call() 中可以抛出异常。

### 5 线程有哪些状态？ 

（New） 新建
当使用new 操作时创建一个线程时，该线程还没有运行，者以外他的状态都是new 状态，
（Runnable） 可运行/就绪状态 。
一旦新状态线程调用start() 方法，线程就处在Runnable  状态。
（Running） 运行中
当线程获得CPU 时间片，线程进入Running 态，而run 方法没有运行完，线程就处在Runnable 状态。
通常情况下   运行中的线程一直处在Running 和Runnable 交替转换状态。
Blocked(等待/阻塞/睡眠)
 当线程在Running 状态中，遇到阻塞状态等待锁  等待用户输入调用sleep() 方法，调用join() 
 等待其他线程情况，会导致线程进入阻塞状态，
 处于阻塞状态的线程，在阻塞等待结束了之后会进入Runnable状态。等待CPU时间段继续运行程序。

Dead (死亡状态)
当线程运行完成run() 方法。直接进入死亡状态dead.

### 6 sleep（）和wait() 有啥区别？

（使用限制)使用sleep()方法可以让当前线程休眠。时间等道当前线程继续往下执行。在任何地方都能使用。
但是需要捕获打断异常。而wait() 还需要notify() notifyAll()进行唤醒。他们需要放在synchronized 代码块中。
切获取对象的锁。
使用场景:sleep()一般用在当前线程休眠。或者循环中暂停操作。wait() 用在多线程之间的通信。
所属类：sleep 为  Thread 类中的静态方法。wait() 则是Object类中的本地方法。
释放锁:wait ()可以释放当前线程中锁。而sleep() 方法不会释放线程中的锁。

### 7 notify()和 notifyAll() 区别？

notify() 方法就是允许一个线程许可进入等待区的线程，至于那个线程进入，就靠他们竞争了。
给等待区的所有线程都重新发放了进门许可。

### 8 创建线程池有哪几种方式？ 

newSingleThreadExecutor(): 创建一个单线程的线程池。如果这个线程因为异常结束，那么就会有新的线程来代替。此线程的所有任务执行顺序都是按照顺序来执行的。

newFixedThreadPool() :创建固定大小的线程池，每次创建一个任务，就是创建一个线程，直到线程达到线程池的最大大小。线程池的大小一旦达到最大的分制就保持不变。如果某个线程因为异常结束，那么线程池就会补充一个新的线程。

newCachedThreadPool() :

创建一个可缓存的线程池，如果线程池的大小超过了处理任务所需的线程，那么就会回收部分空闲的线程，当任务增加时，此线程池又可以智能的增加新线程进来处理任务。线程池大小完全依赖操作系统能够够创建的最大线程大小。

newShedulerThreadPool(): 创建一个大小无线的线程池。此线程支持定时以及周期性执行任务。

线程池重要参数信息：

**corePoolSize** 核心线程池的大小，在线程池创建以后，其实里面是没有没有线程的。当然，当调用presartALLCoreThreads() 或者prestartCoreThread() 方法来于创建线程池。而不用等待任务进来。当任务进来的时候，才会创建线程。当线程池中的线程数量达到CorePoolSize() 之后，就会把任务放在缓存队列中。就是workQueue。

**maxImumPoolSize:** 最大线程数量是多少。他标志着这个线程池的最大线程数量。如果没有最大数量，当创建的线程数量达到一个极限值，内存坑定就会爆掉了。

keepAilveTime: 当线程没有任务时，最多保持时间，超过这个时间就会被终止，默认情况下，当线程池的线程数量达到核心线程数量时，keepAllTIme 值才是会起作用的。

**workQueue**: 用来存储待执行任务的队列。不同的线程中队列的实现方式是不一样的。

```java
 ArrayBlockingQueue：基于数组的队列，创建时需要指定大小。 
 LinkedBlockingQueue：基于链表的队列，如果没有指定大小，则默认值是 Integer.MAX_VALUE。（newFixedThreadPool和newSingleThreadExecutor使用的就是这种队列）。 
 SynchronousQueue：这种队列比较特殊，因为不排队就直接创建新线程把任务提交了。（newCachedThreadPool使用的就是这种队列）。
```

Unit： 参数KeepAliveTime 的时间单位。

threadFactory 线程工厂,用来创建线程。

handler拒绝执行任务的策略：

（1） ThreadPoolExecutor.AbortPolicy 丢弃任务，并抛出 RejectedExecutionException 异常。
（2） ThreadPoolExecutor.CallerRunsPolicy：该任务被线程池拒绝，由调用 execute方法的线程执行该任务。
（3） ThreadPoolExecutor.DiscardOldestPolicy ： 抛弃队列最前面的任务，然后重新尝试执行任务。
（4） ThreadPoolExecutor.DiscardPolicy，丢弃任务，不过也不抛出异常。



### **9.线程池都有哪些状态？**

线程池的5种状态：Running、ShutDown、Stop、Tidying、Terminated。

1、RUNNING

(1) 状态说明：线程池处在RUNNING状态时，能够接收新任务，以及对已添加的任务进行处理。
(02) 状态切换：线程池的初始化状态是RUNNING。换句话说，线程池被一旦被创建，就处于RUNNING状态，并且线程池中的任务数为0！

2、 SHUTDOWN

(1) 状态说明：线程池处在SHUTDOWN状态时，不接收新任务，但能处理已添加的任务。
(2) 状态切换：调用线程池的shutdown()接口时，线程池由RUNNING -> SHUTDOWN。

3、STOP

(1) 状态说明：线程池处在STOP状态时，不接收新任务，不处理已添加的任务，并且会中断正在处理的任务。
(2) 状态切换：调用线程池的shutdownNow()接口时，线程池由(RUNNING or SHUTDOWN ) -> STOP。

4、`TIDYING`

(1) 状态说明：当所有的任务已终止，ctl记录的”任务数量”为0，线程池会变为TIDYING状态。当线程池变为TIDYING状态时，会执行钩子函数terminated()。terminated()在ThreadPoolExecutor类中是空的，若用户想在线程池变为TIDYING时，进行相应的处理；可以通过重载terminated()函数来实现。
(2) 状态切换：当线程池在SHUTDOWN状态下，阻塞队列为空并且线程池中执行的任务也为空时，就会由 SHUTDOWN -> TIDYING。
当线程池在STOP状态下，线程池中执行的任务为空时，就会由STOP -> TIDYING。

5、 `TERMINATED`

(1) 状态说明：线程池彻底终止，就变成TERMINATED状态。
(2) 状态切换：线程池处在TIDYING状态时，执行完terminated()之后，就会由 TIDYING -> TERMINATED

### **10.多线程锁的升级原理是什么？**

因为Sychronized 是重量级锁，（也称之为悲观锁。）每次再锁请求的时候，如果当前资源被其他线程占有要将当前线程阻塞的加入阻塞队列中，然后清空当前线程的缓存，等到锁释放的时候通过notify或者notifyAll 唤醒当前线程，并让其处于就绪状态，这样的线程来回切换是非常消耗资源的，而且线程刚唤醒就挂起，线程刚挂起线程就释放了。而Java的线程映射到操作系统的原生线程之上的每次线程阻塞或者唤醒都是要经过用户太到和心态或者和心态到用户态的和转化，这样是十分浪费资源的，因此JVM 对Sychronized 进行了优化，将锁分为三种锁，偏向锁，轻量级锁，重量级锁。

很多的时候，对于一个可能发生并发访问的对象而言，其实很少会被竞争，就算有些资源存在竞争也是在很少的一段时间资源就会被释放，而这样的情况下将线程挂起是十分浪费性能的。
偏向锁（乐观锁）：
当锁对象第一次被线程获取的时候，虚拟机会将锁对象的对象头中的锁标志位设置成为01，并将偏向锁标志设置为1，线程通过CAS的方式将自己的ID值放置到对象头中（因为在这个过程中有可能会有其他线程来竞争锁，所以要通过CAS的方式，一旦有竞争就会升级为轻量级锁了），如果成功线程就获得了该轻量级锁。这样每次再进入该锁对象的时候不用进行任何的同步操作，直接比较当前锁对象的对象头是不是该线程的ID，如果是就可以直接进入。

偏向锁升级为轻量级锁
偏向锁是一种无竞争锁，一旦出现了竞争大多数情况下就会升级为轻量级锁。现在我们假设有线程1持有偏向锁，线程2来竞争偏向锁会经历以下几个过程：

1. 首先线程2会先检查偏向锁标记，如果是1，说明当前是偏向锁，那么JVM会找到线程1，看线程1是否还存活着2
2. 如果线程1已经执行完毕，就是说线程1不存在了（线程1自己是不会去释放偏向锁的），那么先将偏向锁置为0，对象头设置成为无锁的状态，用CAS的方式尝试将线程2的ID放入对象头中，不进行锁升级，还是偏向锁
3. 如果线程1还活着，先暂停线程1，将锁标志位变成00（轻量级锁）然后在线程1的栈帧中开辟出一块空间（Display Mark Word）将对象头的Mark Word置换到线程一的栈帧当中，而对象头中此时存储的是指向当前线程栈帧的指针。此时就变成了轻量级锁。继续执行线程1，然后线程2采用CAS的方式尝试获取锁。

轻量级锁与偏向锁最大的不同之处
轻量级锁和偏向锁的不同之处就在于轻量级锁对于获取锁对象采用CAS的同步方式而偏向锁直接是把整个同步过程给取消。

轻量级锁(乐观锁)
轻量级锁如何创建在上面已经讲过了，接下来说说轻量级锁如何获取锁对象，轻量级锁是通过CAS也就是自旋的方式尝试获取锁对象，一旦失败会先检查，对象头中存储的是否是指向当前线程栈帧的指针，如果是，就可以获取对象，如果不是说明存在竞争那么就要膨胀为重量级锁。轻量级锁的解锁也是通过CAS的方式尝试将对象头的Mark Word和线程中的Display Mark Word替换回来，如果成功，就释放锁，如果失败说明还有许多其他等待锁的线程（说明此时已经不是轻量级锁而是重量级锁了），会将这些线程唤醒，然后释放锁。

轻量级锁膨胀为重量级锁
一旦有两条以上的线程竞争锁，轻量级锁膨胀为重量级锁，锁的状态变成10，此时对象头中存储的就是指向重量级锁的栈帧的指针。而且其他等待锁的线程要进入阻塞状态，等待重量级锁释放再来被唤醒然后去竞争。